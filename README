# Team Members
Allen Lee and Robert O'Neill

# New compiler functionality

For this assignment, we implemented the requisite procedure entry and
exit functions, the Frame.string function, as well as adding the cruft
that spim requires to run a program.

We also implemented coalescing in our register allocator. It seems to
more or less work properly. Our register allocator now colors, spills,
and coalesces.

The following entry/exit functions were modified:

## procEntryExit1

This function adds IR to save and restore calle saves registers $ra,
and $s0-$s7 to fresh temps.  At the beginning and end of procedures.
The register allocator should coalesce these moves.

## procEntryExit3

We added the prolog and epilog assembly instructions to create and
destroy stack frames. This function adjust the stack pointer, saves
the old frame pointer and return address, and creates the new frame
pointer from the old stack pointer.

We also made numerous bug fixes in many parts of the compiler.

# How to run

1.) To compile the program "prog.tig" call:

    > echo 'Compiler.compile "prog.tig";' | sml sources.cm

2.) If the program compiles successfully, the compiler will emit a file
    "prog.tig.s"

3.) In order to run this file in spim, "prog.tig.s" and the runtime system,
    "runtime.s" and "sysspim.s" must be concatenated

    > cat prog.tig.s runtime.s sysspim.s  > "prog.s"

4.) Use spim to execute "prog.s"
    > spim -file prog.s

# Factorial
The assembly output for a recursive factorial program:

    let
	function factorial(n:int) : int =
        	 if n = 0 then 1
		 else n * factorial(n-1)
    in factorial(5)
    end

is 

.data
.text

.text
tig_main:
addi $sp, $sp, -8
sw $fp, 4($sp)
sw $ra, 0($sp)
addi $fp, $sp, 8
L468:
sw $a0, 0($fp)
la $t8, L463
li $t9, 5
addi $sp, $sp, -8
move $a1, $t9
move $a0, $fp
jal $t8
move $v0, $v0
b L467
L467:
lw $fp, 4($sp)
lw $ra, 0($sp)
addi $sp, $sp, 16
jr $ra
.end tig_main

.text
L463:
addi $sp, $sp, -12
sw $fp, 4($sp)
sw $ra, 0($sp)
addi $fp, $sp, 12
L470:
sw $a0, 0($fp)
beqz $a1, L465
L466:
sw $a1, -4($fp)
la $t7, L463
lw $t8, 0($fp)
addi $t9, $a1, -1
addi $sp, $sp, -8
move $a1, $t9
move $a0, $t8
jal $t7
move $a3, $v0
lw $t9, -4($fp)
mul $t9, $t9, $a3
L464:
move $v0, $t9
b L469
L465:
li $t9, 1
b L464
L469:
lw $fp, 4($sp)
lw $ra, 0($sp)
addi $sp, $sp, 20
jr $ra
.end L463


